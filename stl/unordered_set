#ifndef __unordered_set__
#define __unordered_set__

/*
  File
  ----
  unordered_set
  
  Description
  -----------
  A hash table implementation.

  Authors:
  Justin R. Wilson
*/

#include <functional>
#include <memory>
#include <utility>

namespace std {

  template <class Key, class Hash>
  struct drop {
    drop* next;
    Hash hash;
    Key key;

    drop (Hash h,
	  const Key& k) :
      next (0),
      hash (h),
      key (k)
    { }
  };

  template <class T, class Hash = std::hash<T>, class Predicate = std::equal_to<T>, class Allocator = allocator<T> >
  class unordered_set :
    private Hash,
    private Predicate,
    private Allocator::template rebind<drop<T, typename Hash::result_type> >::other,
    private Allocator::template rebind<drop<T, typename Hash::result_type>*>::other {
  private:
    typedef drop<T, typename Hash::result_type> drop_type;
    typedef typename Allocator::template rebind<drop_type>::other drop_allocator_type;
    typedef typename Allocator::template rebind<drop_type *>::other bucket_allocator_type;
    
    struct Iterator;
    struct LocalIterator;

  public:
    typedef T key_type;
    typedef T value_type;
    typedef Hash hasher;
    typedef Predicate key_equal;
    typedef Allocator allocator_type;
    typedef typename Allocator::pointer pointer;
    typedef typename Allocator::const_pointer const_pointer;
    typedef typename Allocator::reference reference;
    typedef typename Allocator::const_reference const_reference;
    typedef typename Allocator::size_type size_type;
    typedef typename Allocator::difference_type difference_type;

    typedef Iterator iterator;
    typedef Iterator const_iterator;
    typedef LocalIterator local_iterator;
    typedef LocalIterator const_local_iterator;

  private:
    typedef typename Hash::result_type hash_type;

    struct Iterator : public std::iterator<std::forward_iterator_tag, T> {
      drop_type** drop;

      Iterator (drop_type** l) :
	drop (l)
      { }

      bool
      operator== (const Iterator& other) const
      {
	return drop == other.drop;
      }

      bool
      operator!= (const Iterator& other) const
      {
	return !(*this == other);
      }
    };

    drop_type**
    allocate_buckets (size_type n)
    {
      drop_type** retval = bucket_allocator_type::allocate (n);
      for (size_type idx = 0; idx < n; ++idx) {
	retval[idx] = 0;
      }
      return retval;
    }

    size_type bucket_count_;
    size_type drop_count_;
    float max_load_factor_;
    size_type max_drop_count_;
    drop_type** bucket_;

  public:

    explicit unordered_set (size_type n = 3,
			    const hasher& h = hasher (),
			    const key_equal& ke = key_equal (),
			    const allocator_type& a = allocator_type ()) :
      Hash (h),
      Predicate (ke),
      drop_allocator_type (a),
      bucket_allocator_type (a),
      bucket_count_ (n),
      drop_count_ (0),
      max_load_factor_ (.70),
      max_drop_count_ (max_load_factor_ * bucket_count_)
    {
      bucket_ = allocate_buckets (bucket_count_);
    }

    template <class InputIterator>
    unordered_set (InputIterator begin,
		   InputIterator end,
		   size_type n = 3,
		   const hasher& h = hasher (),
		   const key_equal& ke = key_equal (),
		   const allocator_type& a = allocator_type ());

    unordered_set (const unordered_set&);

    ~unordered_set ()
    {
      clear ();
      bucket_allocator_type::deallocate (bucket_, bucket_count_);
    }

    unordered_set&
    operator= (const unordered_set&);

    allocator_type get_allocator () const;

    bool
    empty () const
    {
      return drop_count_ == 0;
    }

    size_type
    size () const
    {
      return drop_count_;
    }

    size_type
    max_size () const;

    iterator
    begin ();

    const_iterator
    begin () const;

    iterator
    end ()
    {
      return iterator (0);
    }

    const_iterator
    end () const
    {
      return iterator (0);
    }

    iterator
    insert (const value_type& v)
    {
      const hash_type hash = Hash::operator() (v);
      const size_type bucket_idx = hash % bucket_count_;

      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->key, v)) {
	  return iterator (ptr);
	}
	ptr = &(*ptr)->next;
      }

      drop_type* drop = drop_allocator_type::allocate (1);
      drop_allocator_type::construct (drop, drop_type (hash, v));
      ++drop_count_;
      *ptr = drop;

      if (drop_count_ > max_drop_count_) {
	rehash (2 * bucket_count_);
      }

      return iterator (ptr);
    }

    iterator
    insert (const_iterator hint,
	    const value_type& v);

    template <class InputIterator>
    void
    insert (InputIterator begin,
	    InputIterator end);

    void
    erase (const_iterator position)
    {
      drop_type* tmp = *position.drop;
      *position.drop = tmp->next;
      drop_allocator_type::destroy (tmp);
      drop_allocator_type::deallocate (tmp, 1);
      --drop_count_;
    }
    
    size_type
    erase (const key_type& k);

    void
    erase (const_iterator begin,
	   const_iterator end);

    void
    clear ()
    {
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	while (bucket_[idx] != 0) {
	  drop_type* ptr = bucket_[idx];
	  bucket_[idx] = ptr->next;
	  drop_allocator_type::destroy (ptr);
	  drop_allocator_type::deallocate (ptr, 1);
	}
      }
      drop_count_ = 0;
    }

    void
    swap (unordered_set&);

    hasher hash_function () const;

    key_equal key_eq () const;

  private:
    iterator
    find_ (const key_type& k)
    {
      const hash_type hash = Hash::operator() (k);
      const size_type bucket_idx = hash % bucket_count_;
      
      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->key, k)) {
	  return iterator (ptr);
	}
	ptr = &(*ptr)->next;
      }
      
      return iterator (0);
    }
    
  public:
    iterator
    find (const key_type& k)
    {
      return find_ (k);
    }

    const_iterator
    find (const key_type& k) const
    {
      return find_ (k);
    }

    size_type
    count (const key_type& k) const;

    std::pair<iterator, iterator>
    equal_range (const key_type& k);

    std::pair<const_iterator, const_iterator>
    equal_range (const key_type& k) const;

    size_type
    bucket_count () const
    {
      return bucket_count_;
    }

    size_type
    max_bucket_count () const;

    size_type
    bucket_size (size_type n) const;

    size_type
    bucket (const key_type& k) const;

    local_iterator
    begin (size_type n);

    const_local_iterator
    begin (size_type n) const;

    local_iterator
    end (size_type n);

    const_local_iterator
    end (size_type n) const;

    float
    load_factor () const;

    float
    max_load_factor () const
    {
      return max_load_factor_;
    }

    void
    max_load_factor (float z);

    void
    rehash (size_type n)
    {
      if (n > bucket_count_) {
	drop_type** new_bucket = allocate_buckets (n);
	for (size_type idx = 0; idx < bucket_count_; ++idx) {
	  while (bucket_[idx] != 0) {
	    drop_type* drop = bucket_[idx];
	    bucket_[idx] = drop->next;
	    size_type new_idx = drop->hash % n;
	    drop->next = new_bucket[new_idx];
	    new_bucket[new_idx] = drop;
	  }
	}

	bucket_allocator_type::deallocate (bucket_, bucket_count_);

	bucket_count_ = n;
	max_drop_count_ = max_load_factor_ * bucket_count_;
	bucket_ = new_bucket;
      }
    }
  };

}

/* Local Variables: */
/* mode:c++         */
/* End:             */

#endif /* __unordered_set__ */
