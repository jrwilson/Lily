#ifndef __unordered_set__
#define __unordered_set__

/*
  File
  ----
  unordered_set
  
  Description
  -----------
  A hash table implementation.

  Authors:
  Justin R. Wilson
*/

#include <functional>
#include <memory>
#include <utility>
#include <iterator>

namespace std {

  template <class Key, class Hash>
  struct us_drop {
    us_drop* next;
    Hash hash;
    const Key key;

    us_drop (Hash h,
	     const Key& k) :
      next (0),
      hash (h),
      key (k)
    { }
  };

  template <class T, class Hash = std::hash<T>, class Predicate = std::equal_to<T>, class Allocator = allocator<T> >
  class unordered_set :
    private Hash,
    private Predicate,
    private Allocator,
    private Allocator::template rebind<us_drop<T, typename Hash::result_type> >::other,
    private Allocator::template rebind<us_drop<T, typename Hash::result_type>*>::other {
  private:
    typedef us_drop<T, typename Hash::result_type> drop_type;
    typedef typename Allocator::template rebind<drop_type>::other drop_allocator_type;
    typedef typename Allocator::template rebind<drop_type *>::other bucket_allocator_type;
    
    struct Iterator;
    struct LocalIterator;

  public:
    typedef T key_type;
    typedef T value_type;
    typedef Hash hasher;
    typedef Predicate key_equal;
    typedef Allocator allocator_type;
    typedef typename Allocator::pointer pointer;
    typedef typename Allocator::const_pointer const_pointer;
    typedef typename Allocator::reference reference;
    typedef typename Allocator::const_reference const_reference;
    typedef typename Allocator::size_type size_type;
    typedef typename Allocator::difference_type difference_type;

    typedef Iterator iterator;
    typedef Iterator const_iterator;
    typedef LocalIterator local_iterator;
    typedef LocalIterator const_local_iterator;

  private:
    typedef typename Hash::result_type hash_type;

    struct Iterator : public std::iterator<std::forward_iterator_tag, T> {
      drop_type** drop;
      const unordered_set* set;

      Iterator (drop_type** l,
		const unordered_set* s) :
	drop (l),
	set (s)
      { }

      Iterator () :
	drop (0),
	set (0)
      { }

      bool
      operator== (const Iterator& other) const
      {
	return drop == other.drop;
      }

      bool
      operator!= (const Iterator& other) const
      {
	return !(*this == other);
      }

      Iterator&
      operator++ ()
      {
	if (drop != 0) {
	  drop_type* ptr = *drop;
	  if (ptr->next == 0) {
	    size_type bucket_idx;
	    for (bucket_idx = (ptr->hash % set->bucket_count_) + 1;
		 bucket_idx < set->bucket_count_ && set->bucket_[bucket_idx] == 0;
		 ++bucket_idx) ;;
	    if (bucket_idx < set->bucket_count_) {
	      drop = &set->bucket_[bucket_idx];
	    }
	    else {
	      drop = 0;
	    }
	  }
	  else {
	    drop = &ptr->next;
	  }
	}

	return *this;
      }

      const_pointer
      operator-> () const
      {
	return &(*drop)->key;
      }

      const_reference
      operator* () const
      {
	return (*drop)->key;
      }
    };

    drop_type**
    allocate_buckets (size_type n)
    {
      drop_type** retval = bucket_allocator_type::allocate (n);
      for (size_type idx = 0; idx < n; ++idx) {
	retval[idx] = 0;
      }
      return retval;
    }

    size_type bucket_count_;
    size_type drop_count_;
    float max_load_factor_;
    size_type max_drop_count_;
    drop_type** bucket_;

  public:

    explicit unordered_set (size_type n = 3,
			    const hasher& h = hasher (),
			    const key_equal& ke = key_equal (),
			    const allocator_type& a = allocator_type ()) :
      Hash (h),
      Predicate (ke),
      Allocator (a),
      drop_allocator_type (a),
      bucket_allocator_type (a),
      bucket_count_ (n),
      drop_count_ (0),
      max_load_factor_ (.70),
      max_drop_count_ (max_load_factor_ * bucket_count_)
    {
      bucket_ = allocate_buckets (bucket_count_);
    }

    template <class InputIterator>
    unordered_set (InputIterator begin,
		   InputIterator end,
		   size_type n = 3,
		   const hasher& h = hasher (),
		   const key_equal& ke = key_equal (),
		   const allocator_type& a = allocator_type ());

    unordered_set (const unordered_set& other) :
      Hash (other),
      Predicate (other),
      Allocator (other),
      drop_allocator_type (other),
      bucket_allocator_type (other),
      bucket_count_ (other.bucket_count_),
      drop_count_ (other.drop_count_),
      max_load_factor_ (other.max_load_factor_),
      max_drop_count_ (other.max_drop_count_)
    {
      bucket_ = allocate_buckets (bucket_count_);

      for (size_type idx = 0; idx < bucket_count_; ++idx) {
      	for (drop_type* ptr = other.bucket_[idx]; ptr != 0; ptr = ptr->next) {
      	  drop_type* drop = drop_allocator_type::allocate (1);
      	  drop_allocator_type::construct (drop, *ptr);
      	  drop->next = bucket_[idx];
      	  bucket_[idx] = drop;
      	}
      }
    }

    ~unordered_set ()
    {
      clear ();
      bucket_allocator_type::deallocate (bucket_, bucket_count_);
    }

    unordered_set&
    operator= (const unordered_set&);

    allocator_type
    get_allocator () const;

    bool
    empty () const
    {
      return drop_count_ == 0;
    }

    size_type
    size () const
    {
      return drop_count_;
    }

    size_type
    max_size () const;

  private:
    iterator
    begin_ () const
    {
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	if (bucket_[idx] != 0) {
	  return iterator (&bucket_[idx], this);
	}
      }

      return end ();
    }

  public:
    iterator
    begin ()
    {
      return begin_ ();
    }

    const_iterator
    begin () const
    {
      return begin_ ();
    }

    iterator
    end ()
    {
      return iterator (0, this);
    }

    const_iterator
    end () const
    {
      return iterator (0, this);
    }

    iterator
    insert (const value_type& v)
    {
      const hash_type hash = Hash::operator() (v);
      const size_type bucket_idx = hash % bucket_count_;

      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->key, v)) {
	  return iterator (ptr, this);
	}
	ptr = &(*ptr)->next;
      }

      drop_type* drop = drop_allocator_type::allocate (1);
      drop_allocator_type::construct (drop, drop_type (hash, v));
      ++drop_count_;
      *ptr = drop;

      if (drop_count_ <= max_drop_count_) {
	return iterator (ptr, this);
      }
      else {
	// Rehashing blows away ptr.
	rehash_n (2 * bucket_count_);
	return find (v);
      }
    }

    iterator
    insert (const_iterator hint,
	    const value_type& v);

    template <class InputIterator>
    void
    insert (InputIterator begin,
	    InputIterator end);

    void
    erase (const_iterator position)
    {
      drop_type* tmp = *position.drop;
      *position.drop = tmp->next;
      drop_allocator_type::destroy (tmp);
      drop_allocator_type::deallocate (tmp, 1);
      --drop_count_;
    }
    
    size_type
    erase (const key_type& k);

    void
    erase (const_iterator begin,
	   const_iterator end);

    void
    clear ()
    {
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	while (bucket_[idx] != 0) {
	  drop_type* ptr = bucket_[idx];
	  bucket_[idx] = ptr->next;
	  drop_allocator_type::destroy (ptr);
	  drop_allocator_type::deallocate (ptr, 1);
	}
      }
      drop_count_ = 0;
    }

    void
    swap (unordered_set&);

    hasher hash_function () const;

    key_equal key_eq () const;

  private:
    iterator
    find_ (const key_type& k)
    {
      const hash_type hash = Hash::operator() (k);
      const size_type bucket_idx = hash % bucket_count_;
      
      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->key, k)) {
	  return iterator (ptr, this);
	}
	ptr = &(*ptr)->next;
      }
      
      return iterator (0, this);
    }
    
  public:
    iterator
    find (const key_type& k)
    {
      return find_ (k);
    }

    const_iterator
    find (const key_type& k) const
    {
      return find_ (k);
    }

    size_type
    count (const key_type& k) const;

    std::pair<iterator, iterator>
    equal_range (const key_type& k);

    std::pair<const_iterator, const_iterator>
    equal_range (const key_type& k) const;

    size_type
    bucket_count () const
    {
      return bucket_count_;
    }

    size_type
    max_bucket_count () const;

    size_type
    bucket_size (size_type n) const;

    size_type
    bucket (const key_type& k) const;

    local_iterator
    begin (size_type n);

    const_local_iterator
    begin (size_type n) const;

    local_iterator
    end (size_type n);

    const_local_iterator
    end (size_type n) const;

    float
    load_factor () const;

    float
    max_load_factor () const
    {
      return max_load_factor_;
    }

    void
    max_load_factor (float z);

  private:
    void
    rehash_n (size_type n)
    {
      drop_type** new_bucket = allocate_buckets (n);
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	while (bucket_[idx] != 0) {
	  drop_type* drop = bucket_[idx];
	  bucket_[idx] = drop->next;
	  size_type new_idx = drop->hash % n;
	  drop->next = new_bucket[new_idx];
	  new_bucket[new_idx] = drop;
	}
      }
      
      bucket_allocator_type::deallocate (bucket_, bucket_count_);
      
      bucket_count_ = n;
      max_drop_count_ = max_load_factor_ * bucket_count_;
      bucket_ = new_bucket;
    }

  public:
    void
    rehash (size_type n)
    {
      if (n > bucket_count_) {
	rehash_n (n);
      }
    }
  };

}

/* Local Variables: */
/* mode:c++         */
/* End:             */

#endif /* __unordered_set__ */
