This document is a guide for hacking on the Lily kernel.

C++ vs. C
---------

C and C++ are the two main languages that one might consider when developing an operating system kernel with efficiency being the historical argument against using C++.
The root of this argument is that a custom implementation of certain C++ language features, e.g., virtual inheritance, might be more efficient than the implementation generated by a C++ compiler.
Similarly, one could argue that a custom implementation could be more efficient than an implementation that uses the containers and algorithms in the Standard Template Library (STL).
Today, I don't believe either of these arguments have much merit.
A good C++ compiler can generate very efficient code and many Standard Template Libaries have extraordinarily optimized implementations.
If the efficiency of a C++ language feature became a problem, then reverting to a custom implementation not relying on the C++ feature can be attempted.
Furthermore, the object oriented and generic programming features of C++ provides a significant advantage in terms of human efficiency.
Basically, there is no downside to using C++ as one can always revert to plain old C if necessary.

One open question when developing an operating system kernel with C++ is the role of the STL.
I believe that kernel developers should not use an off-the-shelf STL, rather, they should implement the parts they would like to use.
The main reason is that the STL is designed for general purpose applications instead of operating system kernels, thus, the library implementer might make decisions that are inappropriate for an operating system kernel.
The STL and operating system kernel must be free to evolve independently.
The STL consists of header files that define the various containers and algorithms and a number of support libraries that contain actual compiled code.
As an example, the unordered set/map and hashing implementations in the GNU libstdc++-v3 use a table of prime numbers.
As a kernel developer pulls in more features of the STL, more of the compiled code must be included, regardless of whether it is used or not.
It is my experience that creating a free standing version of the STL is currently difficult or impossible.
(However, this may change as their is interest is using C++ on embedded systems.)

To summarize, C++ retains everything good about C++ and adds a number of useful features.
The argument that C is more efficient that C++ is quickly losing merit as C++ compilers get better, however, C++ developers always need to be aware of the price of using various language features.
An operating system kernel should not use an off-the-shelf STL implementation to avoid potentially conflicting goals, coupling, etc.

Kernel Development Environment
------------------------------

In this section, we will setup an independent toolchain for kernel hacking.
Using an independent toolchain for kernel development helps coordinate multiple developers, i.e., we are all using the same tools, while mitigating a number of problems, e.g., including a header from the development system.
This section is based on http://wiki.osdev.org/GCC_Cross-Compiler

The prefix contains the final destination of the tools.
I prefer to use my home directory.
lilykcc stands for lily kernel compiler.

$ export PREFIX=/home/justin/lilykcc

The target contains the machine for which this compiler will generate executables.

$ export TARGET=i586-elf

Download and extract binutils-2.20.1, gcc-core-4.4.3, and gcc-g++-4.4.3.
$ pwd
/home/justin/src
$ ls
binutils-2.20.1.tar.bz2  gcc-core-4.4.3.tar.bz2  gcc-g++-4.4.3.tar.bz2
$ tar xjf binutils-2.20.1.tar.bz2
$ tar xjf gcc-core-4.4.3.tar.bz2
$ tar xjf gcc-g++-4.4.3.tar.bz2

Extract them in the same directory which is assumed to the current directory.

Build and install binutils.

$ mkdir build-binutils
$ cd build-binutils
$ ../binutils-2.20.1/configure --target=$TARGET --prefix=$PREFIX --disable-nls
$ make all
$ make install

Build and install g++.

$ cd ..
$ mkdir build-g++
$ cd build-g++
$ export PATH=$PATH:$PREFIX/bin
$ ../gcc-4.4.3/configure --target=$TARGET --prefix=$PREFIX --disable-nls --enable-languages=c++ --without-headers
$ make all-gcc
$ make install-gcc

Update your path to include $PREFIX/bin.

Containers and Algorithms
-------------------------

"Lesser artists borrow; great artists steal." - Pablo Picasso

"Immature poets imitate; mature poets steal; bad poets deface what they take, and good poets make it into something better, or at least something different. The good poet welds his theft into a whole of feeling which is unique, utterly different than that from which it is torn." - T.S. Eliot

The STL is incredibly powerful.
I've reimplemented pieces of the STL to build various pieces of the kernel.
I would qualify my efforts as a lesser artist or bad poet as my goal is not to implement a production version of the STL but implement a kernel.
Consequently, if you reach for something in the STL don't be surprised if...
1.  It's not efficient.  (Feel free to optimize.)
2.  It's not correct.  (Feel free to fix bugs.)
3.  It's not there.  (Feel free to implement.)


