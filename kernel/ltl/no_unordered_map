#ifndef __unordered_map__
#define __unordered_map__

/*
  File
  ----
  unordered_map
  
  Description
  -----------
  A hash table implementation.

  Authors:
  Justin R. Wilson
*/

#include <functional>
#include <memory>
#include <utility>
#include <iterator>

namespace ltl {

  template <class Key, class T, class Hash>
  struct um_drop {
    um_drop* next;
    Hash hash;
    std::pair<const Key, T> value;

    um_drop (Hash h,
	     const std::pair<const Key, T>& v) :
      next (0),
      hash (h),
      value (v)
    { }
  };

  template <class Key, class T, class Hash = std::hash<Key>, class Predicate = std::equal_to<Key>, class Allocator = std::allocator<std::pair<const Key, T> > >
  class unordered_map :
    private Hash,
    private Predicate,
    private Allocator::template rebind<um_drop<Key, T, typename Hash::result_type> >::other,
    private Allocator::template rebind<um_drop<Key, T, typename Hash::result_type>*>::other {
  private:
    typedef um_drop<Key, T, typename Hash::result_type> drop_type;
    typedef typename Allocator::template rebind<drop_type>::other drop_allocator_type;
    typedef typename Allocator::template rebind<drop_type *>::other bucket_allocator_type;
    
    struct Iterator;
    struct ConstIterator;
    struct LocalIterator;
    struct ConstLocalIterator;

  public:
    typedef Key key_type;
    typedef T mapped_type;
    typedef std::pair<const Key, T> value_type;
    typedef Hash hasher;
    typedef Predicate key_equal;
    typedef Allocator allocator_type;
    typedef typename Allocator::pointer pointer;
    typedef typename Allocator::const_pointer const_pointer;
    typedef typename Allocator::reference reference;
    typedef typename Allocator::const_reference const_reference;
    typedef typename Allocator::size_type size_type;
    typedef typename Allocator::difference_type difference_type;

    typedef Iterator iterator;
    typedef ConstIterator const_iterator;
    typedef LocalIterator local_iterator;
    typedef ConstLocalIterator const_local_iterator;

  private:
    typedef typename Hash::result_type hash_type;

    struct Iterator : public std::iterator<std::forward_iterator_tag, value_type> {
      drop_type** drop;
      const unordered_map* map;

      Iterator (drop_type** l,
		const unordered_map* m) :
	drop (l),
	map (m)
      { }

      pointer
      operator-> () const
      {
	return &(*drop)->value;
      }

      bool
      operator== (const Iterator& other) const
      {
	return drop == other.drop;
      }

      bool
      operator!= (const Iterator& other) const
      {
	return !(*this == other);
      }

      Iterator&
      operator++ ()
      {
	if (drop != 0) {
	  drop_type* ptr = *drop;
	  if (ptr->next == 0) {
	    size_type bucket_idx;
	    for (bucket_idx = (ptr->hash % map->bucket_count_) + 1;
		 bucket_idx < map->bucket_count_ && map->bucket_[bucket_idx] == 0;
		 ++bucket_idx) ;;
	    if (bucket_idx < map->bucket_count_) {
	      drop = &map->bucket_[bucket_idx];
	    }
	    else {
	      drop = 0;
	    }
	  }
	  else {
	    drop = &ptr->next;
	  }
	}

	return *this;
      }
    };

    struct ConstIterator : public std::iterator<std::forward_iterator_tag, const value_type> {
      drop_type** drop;
      const unordered_map* map;
      
      ConstIterator (drop_type** l,
		     const unordered_map* m) :
	drop (l),
	map (m)
      { }

      ConstIterator (const Iterator& i) :
	drop (i.drop),
	map (i.map)
      { }

      const_reference
      operator* () const
      {
	return (*drop)->value;
      }

      const_pointer
      operator-> () const
      {
	return &(*drop)->value;
      }

      bool
      operator== (const ConstIterator& other) const
      {
	return drop == other.drop;
      }

      bool
      operator!= (const ConstIterator& other) const
      {
	return !(*this == other);
      }

      ConstIterator&
      operator++ ()
      {
	if (drop != 0) {
	  drop_type* ptr = *drop;
	  if (ptr->next == 0) {
	    size_type bucket_idx;
	    for (bucket_idx = (ptr->hash % map->bucket_count_) + 1;
		 bucket_idx < map->bucket_count_ && map->bucket_[bucket_idx] == 0;
		 ++bucket_idx) ;;
	    if (bucket_idx < map->bucket_count_) {
	      drop = &map->bucket_[bucket_idx];
	    }
	    else {
	      drop = 0;
	    }
	  }
	  else {
	    drop = &ptr->next;
	  }
	}

	return *this;
      }

    };

    drop_type**
    allocate_buckets (size_type n)
    {
      drop_type** retval = bucket_allocator_type::allocate (n);
      for (size_type idx = 0; idx < n; ++idx) {
	retval[idx] = 0;
      }
      return retval;
    }

    size_type bucket_count_;
    size_type drop_count_;
    float max_load_factor_;
    size_type max_drop_count_;
    drop_type** bucket_;

  public:

    explicit unordered_map (size_type n = 3,
			    const hasher& h = hasher (),
			    const key_equal& ke = key_equal (),
			    const allocator_type& a = allocator_type ()) :
      Hash (h),
      Predicate (ke),
      drop_allocator_type (a),
      bucket_allocator_type (a),
      bucket_count_ (n),
      drop_count_ (0),
      max_load_factor_ (.70),
      max_drop_count_ (max_load_factor_ * bucket_count_)
    {
      bucket_ = allocate_buckets (bucket_count_);
    }

    template <class InputIterator>
    unordered_map (InputIterator begin,
		   InputIterator end,
		   size_type n = 3,
		   const hasher& h = hasher (),
		   const key_equal& ke = key_equal (),
		   const allocator_type& a = allocator_type ());

    unordered_map (const unordered_map&);

    ~unordered_map ()
    {
      clear ();
      bucket_allocator_type::deallocate (bucket_, bucket_count_);
    }

    unordered_map&
    operator= (const unordered_map&);

    allocator_type get_allocator () const;

    bool
    empty () const
    {
      return drop_count_ == 0;
    }

    size_type
    size () const
    {
      return drop_count_;
    }

    size_type
    max_size () const;
        
  public:
    iterator
    begin ()
    {
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	if (bucket_[idx] != 0) {
	  return iterator (&bucket_[idx], this);
	}
      }
      
      return end ();
    }

    const_iterator
    begin () const
    {
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	if (bucket_[idx] != 0) {
	  return iterator (&bucket_[idx], this);
	}
      }
      
      return end ();
    }

    iterator
    end ()
    {
      return iterator (0, this);
    }

    const_iterator
    end () const
    {
      return iterator (0, this);
    }

    std::pair<iterator, bool>
    insert (const value_type& v)
    {
      const hash_type hash = Hash::operator() (v.first);
      const size_type bucket_idx = hash % bucket_count_;

      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->value.first, v.first)) {
	  return std::make_pair (iterator (ptr, this), false);
	}
	ptr = &(*ptr)->next;
      }

      drop_type* drop = drop_allocator_type::allocate (1);
      drop_allocator_type::construct (drop, drop_type (hash, v));
      ++drop_count_;
      *ptr = drop;

      if (drop_count_ <= max_drop_count_) {
	return std::make_pair (iterator (ptr, this), true);
      }
      else {
	rehash_n (2 * bucket_count_);
	// Rehashing blows away ptr.
	return std::make_pair (find (v.first), true);
      }
    }

    iterator
    insert (const_iterator hint,
	    const value_type& v);

    template <class InputIterator>
    void
    insert (InputIterator begin,
	    InputIterator end);

    void
    erase (const_iterator position)
    {
      drop_type* tmp = *position.drop;
      *position.drop = tmp->next;
      drop_allocator_type::destroy (tmp);
      drop_allocator_type::deallocate (tmp, 1);
      --drop_count_;
    }
    
    size_type
    erase (const key_type& k)
    {
      iterator pos = find (k);
      if (pos != end ()) {
	erase (pos);
	return 1;
      }
      else {
	return 0;
      }
    }

    void
    erase (const_iterator begin,
	   const_iterator end);

    void
    clear ()
    {
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	while (bucket_[idx] != 0) {
	  drop_type* ptr = bucket_[idx];
	  bucket_[idx] = ptr->next;
	  drop_allocator_type::destroy (ptr);
	  drop_allocator_type::deallocate (ptr, 1);
	}
      }
      drop_count_ = 0;
    }

    void
    swap (unordered_map&);

    hasher hash_function () const;

    key_equal key_eq () const;

    iterator
    find (const key_type& k)
    {
      const hash_type hash = Hash::operator() (k);
      const size_type bucket_idx = hash % bucket_count_;
      
      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->value.first, k)) {
	  return iterator (ptr, this);
	}
	ptr = &(*ptr)->next;
      }
      
      return iterator (0, this);
    }

    const_iterator
    find (const key_type& k) const
    {
      const hash_type hash = Hash::operator() (k);
      const size_type bucket_idx = hash % bucket_count_;
      
      drop_type** ptr = &bucket_[bucket_idx];
      while (*ptr != 0) {
	if ((*ptr)->hash == hash && Predicate::operator () ((*ptr)->value.first, k)) {
	  return const_iterator (ptr, this);
	}
	ptr = &(*ptr)->next;
      }
      
      return const_iterator (0, this);
    }

    size_type
    count (const key_type& k) const;

    std::pair<iterator, iterator>
    equal_range (const key_type& k);

    std::pair<const_iterator, const_iterator>
    equal_range (const key_type& k) const;

    size_type
    bucket_count () const
    {
      return bucket_count_;
    }

    size_type
    max_bucket_count () const;

    size_type
    bucket_size (size_type n) const;

    size_type
    bucket (const key_type& k) const;

    local_iterator
    begin (size_type n);

    const_local_iterator
    begin (size_type n) const;

    local_iterator
    end (size_type n);

    const_local_iterator
    end (size_type n) const;

    float
    load_factor () const;

    float
    max_load_factor () const
    {
      return max_load_factor_;
    }

    void
    max_load_factor (float z);

  private:
    void
    rehash_n (size_type n)
    {
      drop_type** new_bucket = allocate_buckets (n);
      for (size_type idx = 0; idx < bucket_count_; ++idx) {
	while (bucket_[idx] != 0) {
	  drop_type* drop = bucket_[idx];
	  bucket_[idx] = drop->next;
	  size_type new_idx = drop->hash % n;
	  drop->next = new_bucket[new_idx];
	  new_bucket[new_idx] = drop;
	}
      }
      
      bucket_allocator_type::deallocate (bucket_, bucket_count_);
      
      bucket_count_ = n;
      max_drop_count_ = max_load_factor_ * bucket_count_;
      bucket_ = new_bucket;
    }

  public:
    void
    rehash (size_type n)
    {
      if (n > bucket_count_) {
	rehash_n (n);
      }
    }
  };

}

/* Local Variables: */
/* mode:c++         */
/* End:             */

#endif /* __unordered_map__ */
