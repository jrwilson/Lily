#include <automaton.h>
#include <io.h>
#include <fifo_scheduler.h>
#include <string.h>
#include <buffer_file.h>

/*
  PS2 Keyboard and Mouse Driver
  ===============

  The keyboard and mouse system is organized according to the following diagram:

    CPU <=> Peripheral Controller <-> Keyboard / Mouse

  The peripheral controller communicates with the keyboard and mouse via a serial link.
  The peripheral controller communicates with the CPU using I/O ports and an interrupt.
  This driver is for AT+ architectures, i.e., the keyboard contains an 8031 controller and the keyboard controller consists of a 8042 controller.

  The main interface consists of the SCANCODE output action that delivers scan codes from the keyboard.
  If there is demand, the Kscan codes could be delivered instead of the scan codes.

   The mouse is assumed to be a 3 button mouse on the auxiliary port which influences initialization and data read semantics.

 */

/* Data read/written on this port passes through the keyboard controller to the keyboard. */
#define DATA_PORT 0x60
/* Data read/written on this port pertains to the keyboard controller. */
#define CONTROLLER_PORT 0x64

/* Command to get port status */
#define CONTROLLER_GET_COMPAQ_STATUS_BYTE 0x20
/* Command to set port status */
#define CONTROLLER_SET_COMPAQ_STATUS_BYTE 0x60
/* Command to enable auxiliary device */
#define CONTROLLER_ENABLE_AUX_DEVICE 0xA8
/* Command to handshake with mouse data port before sending */
#define CONTROLLER_WRITE_TO_MOUSE 0xD4

/* Command to enable transmission of mouse packets */
#define MOUSE_ENABLE_MOVEMENT_PACKETS 0xF4
/* Command to set mouse defaults */
#define MOUSE_SET_DEFAULTS_AND_DISABLE 0xF6

/* Acknowledgement byte from controller */
#define MOUSE_COMMAND_ACK 0xFA

/* Compaq status bits */
#define ENABLE_IRQ12_BIT 0x2 /* Bit to set to enable aux to generate IRQ12 */
#define DISABLE_MOUSE_CLOCK_BIT 0x20 /* Bit to clear to disable mouse clock */

/* Controller buffer state bits */
#define CONTROLLER_WRITE_BUFFER_FULL_BIT 0x02 /* Bit that indicates write buffer is full */
#define CONTROLLER_READ_READY_BIT 0x01  /* Bit that is set when data port is ready for a read */

/* This is the interrrupt request generated by the keyboard controller. */
#define KEYBOARD_IRQ 1
#define MOUSE_IRQ 12

/* Initialization flag. */
static bool initialized = false;

/* Output buffer containing scan codes. */
static bd_t keyboard_output_buffer_bd = -1;
static buffer_file_t keyboard_output_buffer;

/* Output buffer for (three byte) mouse packets */
static bd_t mouse_output_buffer_bd = -1;
static buffer_file_t mouse_output_buffer;

#define KEYBOARD_INTERRUPT_NO 1
#define SCAN_CODE_NO 2
#define MOUSE_INTERRUPT_NO 3
#define MOUSE_PACKET_NO 4

static void
syslog_print_byte (unsigned char c)
{
  unsigned char upper_nibble = (c >> 4);
  unsigned char lower_nibble = (c & 0xF);
  
  /* signed to make syslog happy, representation size is sufficient even so */ 
  char syslog_byte_string [5] = {'0','x',0,0,0};
  syslog_byte_string [2] = (upper_nibble < 10) ? '0' + upper_nibble : 'a' - 10 + upper_nibble;
  syslog_byte_string [3] = (lower_nibble < 10) ? '0' + lower_nibble : 'a' - 10 + lower_nibble;
  
  syslog ("byte received:");
  syslog (syslog_byte_string);
}

static void
wait_to_send ()
{
  unsigned char c;
  do {
    c = inb (CONTROLLER_PORT);
  } while (c & CONTROLLER_WRITE_BUFFER_FULL_BIT);
}

static unsigned char
read_a_byte ()
{
  unsigned char c;
  do {
    c = inb (CONTROLLER_PORT);
  } while ((c & CONTROLLER_READ_READY_BIT) == 0);
  c = inb (DATA_PORT);
  if (automatonerrno != 0) {
    syslog ("mouse: error:  could not read compaq status byte");
    exit ();
  }
  return c;
}

static void
controller_write_command (unsigned char c)
{
  wait_to_send ();
  if (outb (CONTROLLER_PORT, c) == -1) { 
    syslog ("mouse: error:  could not send byte to mouse");
    syslog_print_byte (c);
    exit ();
  }
}

static void
controller_write_data (unsigned char c)
{
  wait_to_send ();
  if (outb (DATA_PORT, c) == -1) { 
    syslog ("mouse: error:  could not send byte to mouse");
    syslog_print_byte (c);
    exit ();
  }
}

static void
mouse_write_command (unsigned char c)
{
  controller_write_command (CONTROLLER_WRITE_TO_MOUSE);
  controller_write_data (c);
}

static void
initialize (void)
{
  if (!initialized) {
    initialized = true;

    /* Reserve common system resources. */
    if (reserve_port (DATA_PORT) == -1) {
      syslog ("keyboard: error:  Could not reserve data port");
      exit ();
    }
    if (reserve_port (CONTROLLER_PORT) == -1) {
      syslog ("keyboard: error:  Could not reserve controller port");
      exit ();
    }

    /* Reserve keyboard system resources. */
    if (subscribe_irq (KEYBOARD_IRQ, KEYBOARD_INTERRUPT_NO, 0) == -1) {
      syslog ("keyboard: error:  Could not subscribe to keyboard irq");
      exit ();
    }

    /* Create the keyboard output buffer. */
    keyboard_output_buffer_bd = buffer_create (0);
    if (keyboard_output_buffer_bd == -1) {
      syslog ("keyboard: error:  Could not create output buffer");
      exit ();
    }
    if (buffer_file_initw (&keyboard_output_buffer, keyboard_output_buffer_bd) == -1) {
      syslog ("keyboard: error:  Could not initialize output buffer");
      exit ();
    }

    /* Reserve mouse system resources. */
    if (subscribe_irq (MOUSE_IRQ, MOUSE_INTERRUPT_NO, 0) == -1) {
      syslog ("mouse: error:  Could not subscribe to mouse irq");
      exit ();
    }

    /* Create the mouse output buffer. */
    mouse_output_buffer_bd = buffer_create (0);
    if (mouse_output_buffer_bd == -1) {
      syslog ("mouse: error:  Could not create output buffer");
      exit ();
    }
    if (buffer_file_initw (&mouse_output_buffer, mouse_output_buffer_bd) == -1) {
      syslog ("mouse: error:  Could not initialize output buffer");
      exit ();
    }

    /* Handshakes with mouse hardware to initialize, done exactly once. */

    /* Enable aux port, have it generate mouse IRQ 12 */
    controller_write_command (CONTROLLER_ENABLE_AUX_DEVICE);
    controller_write_command (CONTROLLER_GET_COMPAQ_STATUS_BYTE);
    unsigned char c = read_a_byte ();
    c |= ENABLE_IRQ12_BIT;
    c &= ~DISABLE_MOUSE_CLOCK_BIT;
    controller_write_command (CONTROLLER_SET_COMPAQ_STATUS_BYTE);
    controller_write_data (c);

    mouse_write_command (MOUSE_SET_DEFAULTS_AND_DISABLE);
    c = read_a_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }

    mouse_write_command (MOUSE_ENABLE_MOVEMENT_PACKETS);
    c = read_a_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    syslog("success!");

    /* TODO - is this a 3 byte mouse or a 4 byte mouse? 
       save state about that in a global variable, and adjust
       behavior accordingly (initially get 3 byte mouse to work) */

    /* TODO - get basic 3 byte mouse working with keyboard at same time */

    /* TODO - look through list of PS2 mouse commands and see what we would like to issue here or elsewhere */
  }
}

static void
schedule (void);

static void
end_input_action (bd_t bda,
		  bd_t bdb)
{
  if (bda != -1) {
    buffer_destroy (bda);
  }
  if (bdb != -1) {
    buffer_destroy (bdb);
  }
  schedule ();
  scheduler_finish (false, -1, -1);
}

static void
end_output_action (bool output_fired,
		   bd_t bda,
		   bd_t bdb)
{
  schedule ();
  scheduler_finish (output_fired, bda, bdb);
}

BEGIN_SYSTEM_INPUT (INIT, "", "", init, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  end_input_action (bda, bdb);
}

/* keyboard_interrupt
   ------------------
   Process a keyboard interrupt by reading the scancode.
   
   Post: keyboard_output_buffer_initialized == true && the output buffer is not empty
 */
BEGIN_SYSTEM_INPUT (KEYBOARD_INTERRUPT_NO, "", "", keyboard_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  if (buffer_file_put (&keyboard_output_buffer, inb (DATA_PORT)) == -1) {
    syslog ("keyboard: error:  Could not write to output buffer");
    exit ();
  }
  end_input_action (bda, bdb);
}

/* scan_code
   ---------
   Output the scancodes.
   
   Pre:  keyboard_output_buffer_initialized == true && the output buffer is not empty
   Post: keyboard_output_buffer_initialized == false
 */
static bool
scan_code_precondition (void)
{
  return buffer_file_size (&keyboard_output_buffer) != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, SCAN_CODE_NO, "scan_code", "buffer_file", scan_code, int param)
{
  initialize ();
  scheduler_remove (SCAN_CODE_NO, param);

  if (scan_code_precondition ()) {
    buffer_file_truncate (&keyboard_output_buffer);
    end_output_action (true, keyboard_output_buffer_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}


/*===*/

/* mouse_interrupt
   ------------------
   Process a mouse interrupt by reading the movement packet.
   
   Post: ???
 */
BEGIN_SYSTEM_INPUT (MOUSE_INTERRUPT_NO, "", "", mouse_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  syslog("got a mouse packet");
  end_input_action (bda, bdb);
}

/* Output the mouse packet
   ---------
   Output the mouse button and movement variables.
   
   Pre:  ???
   Post: ???
 */
static bool
mouse_packet_precondition (void)
{
  return buffer_file_size (&mouse_output_buffer) != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, MOUSE_PACKET_NO, "mouse_packet", "buffer_file", mouse_packet, int param)
{
  initialize ();
  scheduler_remove (MOUSE_PACKET_NO, param);

  if (mouse_packet_precondition ()) {
    buffer_file_truncate (&mouse_output_buffer);
    end_output_action (true, mouse_output_buffer_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}

/*===*/

static void
schedule (void)
{
  if (scan_code_precondition ()) {
    scheduler_add (SCAN_CODE_NO, 0);
  }
  if (mouse_packet_precondition ()) {
    scheduler_add (MOUSE_PACKET_NO, 0);
  }
}
