#include <automaton.h>
#include <io.h>
#include <fifo_scheduler.h>
#include <string.h>
#include <buffer_file.h>

/*
  Keyboard Driver
  ===============

  The keyboard system is organized according to the following diagram:

    CPU <=> Keyboard Controller <-> Keyboard

  The keyboard controller communicates with the keyboard via a serial link.
  The keyboard controller communicates with the CPU using I/O ports and an interrupt.
  This driver is for AT+ architectures, i.e., the keyboard contains an 8031 controller and the keyboard controller consists of a 8042 controller.

  The main interface consists of the SCANCODE output action that delivers scan codes from the keyboard.
  If there is demand, the Kscan codes could be delivered instead of the scan codes.
 */

/* Data read/written on this port passes through the keyboard controller to the keyboard. */
#define KEYBOARD_DATA_PORT 0x60
/* Data read/written on this port pertains to the keyboard controller. */
#define KEYBOARD_CONTROLLER_PORT 0x64
/* This is the interrrupt request generated by the keyboard controller. */
#define KEYBOARD_IRQ 1

/* Initialization flag. */
static bool initialized = false;

/* Output buffer containing scan codes. */
static bd_t output_buffer_bd = -1;
static buffer_file_t output_buffer;

#define KEYBOARD_INTERRUPT_NO 1
#define SCAN_CODE_NO 2

static void
initialize (void)
{
  if (!initialized) {
    initialized = true;

    /* Reserve system resources. */
    if (reserve_port (KEYBOARD_DATA_PORT) == -1) {
      syslog ("keyboard: error:  Could not reserve data port");
      exit ();
    }
    if (reserve_port (KEYBOARD_CONTROLLER_PORT) == -1) {
      syslog ("keyboard: error:  Could not reserve controller port");
      exit ();
    }
    if (subscribe_irq (KEYBOARD_IRQ, KEYBOARD_INTERRUPT_NO, 0) == -1) {
      syslog ("keyboard: error:  Could not subscribe to keyboard irq");
      exit ();
    }

    /* Create the output buffer. */
    output_buffer_bd = buffer_create (0);
    if (output_buffer_bd == -1) {
      syslog ("keyboard: error:  Could not create output buffer");
      exit ();
    }
    if (buffer_file_initw (&output_buffer, output_buffer_bd) == -1) {
      syslog ("keyboard: error:  Could not initialize output buffer");
      exit ();
    }
  }
}

static void
schedule (void);

static void
end_input_action (bd_t bda,
		  bd_t bdb)
{
  if (bda != -1) {
    buffer_destroy (bda);
  }
  if (bdb != -1) {
    buffer_destroy (bdb);
  }
  schedule ();
  scheduler_finish (false, -1, -1);
}

static void
end_output_action (bool output_fired,
		   bd_t bda,
		   bd_t bdb)
{
  schedule ();
  scheduler_finish (output_fired, bda, bdb);
}

BEGIN_SYSTEM_INPUT (INIT, "", "", init, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  end_input_action (bda, bdb);
}

/* keyboard_interrupt
   ------------------
   Process a keyboard interrupt by reading the scancode.
   
   Post: output_buffer_initialized == true && the output buffer is not empty
 */
BEGIN_SYSTEM_INPUT (KEYBOARD_INTERRUPT_NO, "", "", keyboard_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  if (buffer_file_put (&output_buffer, inb (KEYBOARD_DATA_PORT)) == -1) {
    syslog ("keyboard: error:  Could not write to output buffer");
    exit ();
  }
  end_input_action (bda, bdb);
}

/* scan_code
   ---------
   Output the scancodes.
   
   Pre:  output_buffer_initialized == true && the output buffer is not empty
   Post: output_buffer_initialized == false
 */
static bool
scan_code_precondition (void)
{
  return buffer_file_size (&output_buffer) != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, SCAN_CODE_NO, "scan_code", "buffer_file", scan_code, int param)
{
  initialize ();
  scheduler_remove (SCAN_CODE_NO, param);

  if (scan_code_precondition ()) {
    buffer_file_truncate (&output_buffer);
    end_output_action (true, output_buffer_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}

static void
schedule (void)
{
  if (scan_code_precondition ()) {
    scheduler_add (SCAN_CODE_NO, 0);
  }
}
