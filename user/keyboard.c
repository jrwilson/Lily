#include <automaton.h>
#include <io.h>
#include <fifo_scheduler.h>
#include <string.h>
#include <buffer_file.h>
#include "ps2_mouse_msg.h"

/*
  PS2 Keyboard and Mouse Driver
  ===============

  The keyboard and mouse system is organized according to the following diagram:

    CPU <=> Peripheral Controller <-> Keyboard / Mouse

  The peripheral controller communicates with the keyboard and mouse via a serial link.
  The peripheral controller communicates with the CPU using I/O ports and an interrupt.
  This driver is for AT+ architectures, i.e., the keyboard contains an 8031 controller and the keyboard controller consists of a 8042 controller.

  The main interface consists of the SCANCODE output action that delivers scan codes from the keyboard.
  If there is demand, the Kscan codes could be delivered instead of the scan codes.

   The mouse is assumed to be a 3 button mouse on the auxiliary port which influences initialization and data read semantics.

 */

/* Data read/written on this port passes through the keyboard controller to the keyboard. */
#define DATA_PORT 0x60
/* Data read/written on this port pertains to the keyboard controller. */
#define CONTROLLER_PORT 0x64

/* Command to get port status */
#define CONTROLLER_GET_COMPAQ_STATUS_BYTE 0x20
/* Command to set port status */
#define CONTROLLER_SET_COMPAQ_STATUS_BYTE 0x60
/* Command to enable auxiliary device */
#define CONTROLLER_ENABLE_AUX_DEVICE 0xA8
/* Command to handshake with mouse data port before sending */
#define CONTROLLER_WRITE_TO_MOUSE 0xD4

/* Command to get mouse id  */
#define MOUSE_GET_ID 0xF2
/* Command to get mouse id  */
#define MOUSE_SET_SAMPLE_RATE 0xF3
/* Command to enable transmission of mouse packets */
#define MOUSE_ENABLE_MOVEMENT_PACKETS 0xF4
/* Command to set mouse defaults */
#define MOUSE_SET_DEFAULTS_AND_DISABLE 0xF6

/* Acknowledgement byte from mouse */
#define MOUSE_COMMAND_ACK 0xFA
/* Error response byte from mouse */
#define MOUSE_COMMAND_ERROR 0xFC
/* Negative acknowledgement byte from mouse */
#define MOUSE_COMMAND_NACK 0xFE

/* Compaq status bits */
#define ENABLE_IRQ12_BIT 0x2 /* Bit to set to enable aux to generate IRQ12 */
#define DISABLE_MOUSE_CLOCK_BIT 0x20 /* Bit to clear to disable mouse clock */

/* Controller buffer state bits */
#define CONTROLLER_WRITE_BUFFER_FULL_BIT 0x02 /* Bit that indicates write buffer is full */
#define CONTROLLER_READ_READY_BIT 0x01  /* Bit that is set when data port is ready for a read */

/* Mouse packet bits */
#define BAD_MOUSE_PACKET_BITS (0x80 | 0x40)
#define BASIC_MOUSE_BUTTON_STATUS_BITS (0x4 | 0x2 | 0x1)
#define MOUSE_DELTA_X_SIGN_BIT 0x10 
#define MOUSE_DELTA_Y_SIGN_BIT 0x20
#define EXTRA_BUTTON_STATUS_BITS (0x20 | 0x10)
#define BONUS_BYTE_Z_BITS (0x8 | 0x4 | 0x2 | 0x1)

#define EXTRA_BUTTON_STATUS_OFFSET 1

/* Valid mouse packet z movement values */
#define MOUSE_Z_ZERO 0x0
#define MOUSE_Z_UP 0x1
#define MOUSE_Z_DOWN 0xF
#define MOUSE_Z_LEFT 0xE
#define MOUSE_Z_RIGHT 0x2

/* This is the interrrupt request generated by the keyboard controller. */
#define KEYBOARD_IRQ 1
#define MOUSE_IRQ 12

/* Initialization flag. */
static bool initialized = false;

/* Output buffer containing scan codes. */
static bd_t keyboard_output_buffer_bd = -1;
static buffer_file_t keyboard_output_buffer;

/* Output buffer for (three byte) mouse packets */
static bd_t mouse_packet_bd = -1;
static ps2_mouse_packet_list_t mouse_packet_list;
typedef enum {BASIC_MOUSE = 0, SCROLL_WHEEL_MOUSE = 3, FIVE_BUTTON_SCROLL_WHEEL_MOUSE = 4} mouse_id_t;
static mouse_id_t mouse_id = BASIC_MOUSE;
typedef enum {STATUS_BYTE = 0, DELTA_X_BYTE = 1, DELTA_Y_BYTE = 2, BONUS_BYTE = 3, MAX_MOUSE_PACKET_SIZE} mouse_byte_t;
static mouse_byte_t mouse_byte = STATUS_BYTE;
static unsigned char mouse_packet_data [MAX_MOUSE_PACKET_SIZE];

#define KEYBOARD_INTERRUPT_NO 1
#define SCAN_CODE_NO 2
#define MOUSE_INTERRUPT_NO 3
#define MOUSE_PACKET_NO 4

static void
syslog_print_byte (unsigned char c)
{
  unsigned char upper_nibble = (c >> 4);
  unsigned char lower_nibble = (c & 0xF);
  
  /* signed to make syslog happy, representation size is sufficient even so */ 
  char syslog_byte_string [5] = {'0','x',0,0,0};
  syslog_byte_string [2] = (upper_nibble < 10) ? '0' + upper_nibble : 'a' - 10 + upper_nibble;
  syslog_byte_string [3] = (lower_nibble < 10) ? '0' + lower_nibble : 'a' - 10 + lower_nibble;
  syslog (syslog_byte_string);
}

static void
wait_to_send ()
{
  unsigned char c;
  do {
    c = inb (CONTROLLER_PORT);
  } while (c & CONTROLLER_WRITE_BUFFER_FULL_BIT);
}

static unsigned char
read_byte ()
{
  unsigned char c;
  do {
    c = inb (CONTROLLER_PORT);
  } while ((c & CONTROLLER_READ_READY_BIT) == 0);
  c = inb (DATA_PORT);
  if (automatonerrno != 0) {
    syslog ("mouse: error:  could not read compaq status byte");
    exit ();
  }
  return c;
}

static void
controller_write_command (unsigned char c)
{
  wait_to_send ();
  if (outb (CONTROLLER_PORT, c) != 0) { 
    syslog ("mouse: error:  could not send byte to mouse:");
    syslog_print_byte (c);
    exit ();
  }
}

static void
controller_write_data (unsigned char c)
{
  wait_to_send ();
  if (outb (DATA_PORT, c) != 0) { 
    syslog ("controller: error:  could not send byte to controller:");
    syslog_print_byte (c);
    exit ();
  }
}

static void
mouse_write (unsigned char c)
{
  controller_write_command (CONTROLLER_WRITE_TO_MOUSE);
  controller_write_data (c);
}

static void
mouse_send_scroll_wheel_sequence () {
  if (mouse_id == BASIC_MOUSE) {
    syslog("setting sample rate to 200");
    mouse_write (MOUSE_SET_SAMPLE_RATE);
    unsigned char c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    mouse_write (200);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    syslog("setting sample rate to 100");
    mouse_write (MOUSE_SET_SAMPLE_RATE);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    mouse_write (100);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    syslog("setting sample rate to 80");
    mouse_write (MOUSE_SET_SAMPLE_RATE);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    mouse_write (80);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }

    syslog("getting mouse id");
    mouse_write (MOUSE_GET_ID);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    c = read_byte ();
    if (c == BASIC_MOUSE) {
       syslog("mouse id is unchanged");
    }
    else if (c == SCROLL_WHEEL_MOUSE) {
       syslog("new mouse id is");
       syslog_print_byte (c);
       mouse_id = SCROLL_WHEEL_MOUSE;
    }
  }
}

static void
mouse_send_five_button_sequence () {
  if (mouse_id == SCROLL_WHEEL_MOUSE) {
    syslog("setting sample rate to 200");
    mouse_write (MOUSE_SET_SAMPLE_RATE);
    unsigned char c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    mouse_write (200);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    syslog("setting sample rate to 200 again");
    mouse_write (MOUSE_SET_SAMPLE_RATE);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    mouse_write (200);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    syslog("setting sample rate to 80");
    mouse_write (MOUSE_SET_SAMPLE_RATE);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    mouse_write (80);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }

    syslog("getting mouse id");
    mouse_write (MOUSE_GET_ID);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
    c = read_byte ();
    if (c == SCROLL_WHEEL_MOUSE) {
       syslog("mouse id is unchanged");
    }
    else if (c == FIVE_BUTTON_SCROLL_WHEEL_MOUSE) {
       syslog("new mouse id is");
       syslog_print_byte (c);
       mouse_id = FIVE_BUTTON_SCROLL_WHEEL_MOUSE;
    }
  }
}

static void
write_ps2_mouse_packet () {
  /* do nothing if either bad packet bit is set */
  if ((mouse_packet_data[STATUS_BYTE] & BAD_MOUSE_PACKET_BITS) == 0) {

    mouse_packet_t packet;
    packet.button_status_bits = mouse_packet_data[STATUS_BYTE] & BASIC_MOUSE_BUTTON_STATUS_BITS;
    packet.x_delta = mouse_packet_data[DELTA_X_BYTE];
    packet.y_delta = mouse_packet_data[DELTA_Y_BYTE];
    packet.z_delta_vertical = 0;
    packet.z_delta_horizontal = 0;

    /* TODO - need to initialize time properly */
    packet.time_stamp.seconds = 0;
    packet.time_stamp.nanoseconds = 0;

    switch (mouse_id) {

    case FIVE_BUTTON_SCROLL_WHEEL_MOUSE:
      packet.button_status_bits |= (mouse_packet_data[BONUS_BYTE] & EXTRA_BUTTON_STATUS_BITS) >> EXTRA_BUTTON_STATUS_OFFSET;

      /* This all assumes 1 dimensional track ball scrolling per message */
    case SCROLL_WHEEL_MOUSE:
      switch (mouse_packet_data[BONUS_BYTE] & BONUS_BYTE_Z_BITS) {
      case MOUSE_Z_UP:
	packet.z_delta_vertical = 1;
	break;
      case MOUSE_Z_DOWN:
	packet.z_delta_vertical = -1;
	break;
      case MOUSE_Z_LEFT:
	packet.z_delta_horizontal = -1;
	break;
      case MOUSE_Z_RIGHT:
	packet.z_delta_horizontal = 1;
	break;
      case MOUSE_Z_ZERO:
	break;
      default:
        syslog ("unexpected mouse z movement value");
        syslog_print_byte (mouse_packet_data[BONUS_BYTE] & BONUS_BYTE_Z_BITS);
	break;
      }

    default: // BASIC_MOUSE
      if (mouse_packet_data[STATUS_BYTE] & MOUSE_DELTA_X_SIGN_BIT) {
	packet.x_delta |= 0xFFFFFF00; //-packet.x_delta;
      }
      if (mouse_packet_data[STATUS_BYTE] & MOUSE_DELTA_Y_SIGN_BIT) {
	packet.y_delta |= 0xFFFFFF00; //-packet.y_delta;
      }
    }
    if (ps2_mouse_packet_list_write (&mouse_packet_list,
				     &packet) != 0) {
      syslog ("ps2 mouse: failed to write to mouse packet list");
      exit ();
    }
  }
}

static void
initialize (void)
{
  if (!initialized) {
    initialized = true;

    /* Reserve common system resources. */
    if (reserve_port (DATA_PORT) != 0) {
      syslog ("keyboard: error:  Could not reserve data port");
      exit ();
    }
    if (reserve_port (CONTROLLER_PORT) != 0) {
      syslog ("keyboard: error:  Could not reserve controller port");
      exit ();
    }

    /* Reserve keyboard system resources. */
    if (subscribe_irq (KEYBOARD_IRQ, KEYBOARD_INTERRUPT_NO, 0) != 0) {
      syslog ("keyboard: error:  Could not subscribe to keyboard irq");
      exit ();
    }

    /* Create the keyboard output buffer. */
    keyboard_output_buffer_bd = buffer_create (0);
    if (keyboard_output_buffer_bd == -1) {
      syslog ("keyboard: error:  Could not create output buffer");
      exit ();
    }
    if (buffer_file_initw (&keyboard_output_buffer, keyboard_output_buffer_bd) != 0) {
      syslog ("keyboard: error:  Could not initialize output buffer");
      exit ();
    }

    /* Reserve mouse system resources. */
    if (subscribe_irq (MOUSE_IRQ, MOUSE_INTERRUPT_NO, 0) != 0) {
      syslog ("mouse: error:  Could not subscribe to mouse irq");
      exit ();
    }

    /* Create the mouse output buffer. */
    mouse_packet_bd = buffer_create (0);
    if (mouse_packet_bd == -1) {
      syslog ("mouse: error:  Could not create output buffer");
      exit ();
    }
    if (ps2_mouse_packet_list_initw (&mouse_packet_list, mouse_packet_bd) != 0) {
      syslog ("mouse: error:  Could not initialize output buffer");
      exit ();
    }

    /* Handshakes with mouse hardware to initialize, done exactly once. */

    /* Enable aux port, have it generate mouse IRQ 12 */
    controller_write_command (CONTROLLER_ENABLE_AUX_DEVICE);
    controller_write_command (CONTROLLER_GET_COMPAQ_STATUS_BYTE);
    unsigned char c = read_byte ();
    c |= ENABLE_IRQ12_BIT;
    c &= ~DISABLE_MOUSE_CLOCK_BIT;
    controller_write_command (CONTROLLER_SET_COMPAQ_STATUS_BYTE);
    controller_write_data (c);

    mouse_write (MOUSE_SET_DEFAULTS_AND_DISABLE);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }

    /* TODO - is this a 3 byte mouse or a 4 byte mouse? 
       save state about that in a global variable, and adjust
       behavior accordingly (initially get 3 byte mouse to work) */

    mouse_send_scroll_wheel_sequence ();
    mouse_send_five_button_sequence ();

    switch (mouse_id) {
    case BASIC_MOUSE:
    case SCROLL_WHEEL_MOUSE:
    case FIVE_BUTTON_SCROLL_WHEEL_MOUSE:
      break;
    default:
      syslog ("mouse: error: mouse in unsupported bonus byte packet state");
      exit ();
    }

    syslog("success!");

    /* TODO - get basic 3 byte mouse working with keyboard at same time */

    /* TODO - look through list of PS2 mouse commands and see what we would like to issue here or elsewhere */

    mouse_write (MOUSE_ENABLE_MOVEMENT_PACKETS);
    c = read_byte ();
    if (c != MOUSE_COMMAND_ACK) {
      syslog ("mouse: error:  did not get ack, instead got");
      syslog_print_byte (c);
      exit ();
    }
  }
}

static void
schedule (void);

static void
end_input_action (bd_t bda,
		  bd_t bdb)
{
  if (bda != -1) {
    buffer_destroy (bda);
  }
  if (bdb != -1) {
    buffer_destroy (bdb);
  }
  schedule ();
  scheduler_finish (false, -1, -1);
}

static void
end_output_action (bool output_fired,
		   bd_t bda,
		   bd_t bdb)
{
  schedule ();
  scheduler_finish (output_fired, bda, bdb);
}

BEGIN_SYSTEM_INPUT (INIT, "", "", init, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  end_input_action (bda, bdb);
}

/* keyboard_interrupt
   ------------------
   Process a keyboard interrupt by reading the scancode.
   
   Post: keyboard_output_buffer_initialized == true && the output buffer is not empty
 */
BEGIN_SYSTEM_INPUT (KEYBOARD_INTERRUPT_NO, "", "", keyboard_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  if (buffer_file_put (&keyboard_output_buffer, inb (DATA_PORT)) != 0) {
    syslog ("keyboard: error:  Could not write to output buffer");
    exit ();
  }
  end_input_action (bda, bdb);
}

/* scan_code
   ---------
   Output the scancodes.
   
   Pre:  keyboard_output_buffer_initialized == true && the output buffer is not empty
   Post: keyboard_output_buffer_initialized == false
 */
static bool
scan_code_precondition (void)
{
  return buffer_file_size (&keyboard_output_buffer) != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, SCAN_CODE_NO, "scan_code", "buffer_file", scan_code, int param)
{
  initialize ();
  scheduler_remove (SCAN_CODE_NO, param);

  if (scan_code_precondition ()) {
    buffer_file_truncate (&keyboard_output_buffer);
    end_output_action (true, keyboard_output_buffer_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}


/*===*/

/* mouse_interrupt
   ------------------
   Process a mouse interrupt by reading the movement packet.
   
   Post: ???
 */
BEGIN_SYSTEM_INPUT (MOUSE_INTERRUPT_NO, "", "", mouse_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();

  /* syslog("got a mouse packet byte"); */
  mouse_packet_data [mouse_byte] = read_byte ();
  /* syslog_print_byte (c); */

  switch (mouse_byte) {
  case STATUS_BYTE:
    mouse_byte = DELTA_X_BYTE;
    break;
  case DELTA_X_BYTE:
    mouse_byte = DELTA_Y_BYTE;
    break;
  case DELTA_Y_BYTE:
    if (mouse_id == BASIC_MOUSE) {
      mouse_byte = STATUS_BYTE;
    syslog ("got a complete 3 byte mouse packet");
    write_ps2_mouse_packet ();
    }
    else {
      mouse_byte = BONUS_BYTE;
    }
    break;
  case BONUS_BYTE:
    mouse_byte = STATUS_BYTE;
    syslog ("got a complete 4 byte mouse packet");
    write_ps2_mouse_packet ();
    break;
  default:
    syslog ("mouse: error: unrecognized packet byte state");
    exit ();
  }

  end_input_action (bda, bdb);
}

/* Output the mouse packet
   ---------
   Output the mouse button and movement variables.
   
   Pre:  ???
   Post: ???
 */
static bool
mouse_packet_precondition (void)
{
  return mouse_packet_list.count != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, MOUSE_PACKET_NO, "mouse_packet", "ps2_mouse_packet_list_t", mouse_packet, int param)
{
  initialize ();
  scheduler_remove (MOUSE_PACKET_NO, param);

  if (mouse_packet_precondition ()) {
    if (ps2_mouse_packet_list_reset (&mouse_packet_list) != 0) {
      syslog ("ps2 mouse packet list reset failed");
      exit();
    }
    end_output_action (true, mouse_packet_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}

/*===*/

static void
schedule (void)
{
  if (scan_code_precondition ()) {
    scheduler_add (SCAN_CODE_NO, 0);
  }
  if (mouse_packet_precondition ()) {
    scheduler_add (MOUSE_PACKET_NO, 0);
  }
}
