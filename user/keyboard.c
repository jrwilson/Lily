#include <automaton.h>
#include <io.h>
#include <fifo_scheduler.h>
#include <string.h>
#include <buffer_file.h>

/*
  PS2 Keyboard and Mouse Driver
  ===============

  The keyboard and mouse system is organized according to the following diagram:

    CPU <=> Peripheral Controller <-> Keyboard / Mouse

  The peripheral controller communicates with the keyboard and mouse via a serial link.
  The peripheral controller communicates with the CPU using I/O ports and an interrupt.
  This driver is for AT+ architectures, i.e., the keyboard contains an 8031 controller and the keyboard controller consists of a 8042 controller.

  The main interface consists of the SCANCODE output action that delivers scan codes from the keyboard.
  If there is demand, the Kscan codes could be delivered instead of the scan codes.

   The mouse is assumed to be a 3 button mouse on the auxiliary port which influences initialization and data read semantics.

 */

/* Data read/written on this port passes through the keyboard controller to the keyboard. */
#define DATA_PORT 0x60
/* Data read/written on this port pertains to the keyboard controller. */
#define CONTROLLER_PORT 0x64
/* Command to get port status */
#define GET_COMPAQ_STATUS_BYTE 0x20
/* Command to set port status */
#define SET_COMPAQ_STATUS_BYTE 0x60
/* Command to enable transmission of mouse packets */
#define ENABLE_MOUSE_MOVEMENT_PACKETS 0xF4
/* Command to enable auxiliary device */
#define ENABLE_AUX_DEVICE 0xA8
/* Command to handshake with mouse data port before sending */
#define MOUSE_DATA_HANDSHAKE 0xD4
/* Command to set mouse defaults */
#define SET_DEFAULTS_AND_DISABLE_MOUSE 0xF6
/* Acknowledgement byte from controller */
#define DATA_READY_ACK 0xFA
/* Bit to set to enable aux to generate IRQ12 */
#define ENABLE_IRQ12_BIT 0x2
/* Bit to clear to disable mouse clock */
#define DISABLE_MOUSE_CLOCK_BIT 0x20
/* Bit that remains set until Control port is ready */
#define CONTROL_PORT_NOT_READY_BIT 0x02
/* Bit that clears when data port is ready */
#define CONTROLLER_PORT_READY_BIT 0x01
/* This is the interrrupt request generated by the keyboard controller. */
#define KEYBOARD_IRQ 1
#define MOUSE_IRQ 12

/* Initialization flag. */
static bool initialized = false;

/* Output buffer containing scan codes. */
static bd_t keyboard_output_buffer_bd = -1;
static buffer_file_t keyboard_output_buffer;

/* Output buffer for (three byte) mouse packets */
static bd_t mouse_output_buffer_bd = -1;
static buffer_file_t mouse_output_buffer;

#define KEYBOARD_INTERRUPT_NO 1
#define SCAN_CODE_NO 2
#define MOUSE_INTERRUPT_NO 3
#define MOUSE_PACKET_NO 4

void print_byte(unsigned char c) {
  unsigned char upper_nibble = (c >> 4);
  unsigned char lower_nibble = (c & 0xF); 
  unsigned char syslog_byte_string [5] = {'0','x',0,0,0};
  syslog_byte_string [2] = (upper_nibble < 10) ? '0' + upper_nibble : 'a' - 10 + upper_nibble;
  syslog_byte_string [3] = (lower_nibble < 10) ? '0' + lower_nibble : 'a' - 10 + lower_nibble;
  syslog ("byte received:");
  syslog (syslog_byte_string);
}

void mouse_wait_to_send() {
  unsigned char c;
  do {
    c = inb (CONTROLLER_PORT);
  } while ((c & CONTROL_PORT_NOT_READY_BIT) != 0);
}

void mouse_wait_to_read() {
  unsigned char c;
  do {
    c = inb (CONTROLLER_PORT);
  } while ((c & CONTROLLER_PORT_READY_BIT) == 0);
}

void mouse_wait_for_ack() {
  mouse_wait_to_read();
  unsigned char c;
  unsigned int counter = 0;
  do {
    ++counter;
    c = inb (DATA_PORT);
    print_byte(c);
    if (counter >= 10) {
      exit();
    }
  } while (c != DATA_READY_ACK);
}

void  mouse_data_handshake() {
  mouse_wait_to_send();
  if (outb (CONTROLLER_PORT,MOUSE_DATA_HANDSHAKE) == -1) { 
    syslog ("mouse: error:  could not send mouse data handshake byte");
    exit ();
    }
}

static void
initialize (void)
{
  if (!initialized) {
    initialized = true;

    /* Reserve common system resources. */
    if (reserve_port (DATA_PORT) == -1) {
      syslog ("keyboard: error:  Could not reserve data port");
      exit ();
    }
    if (reserve_port (CONTROLLER_PORT) == -1) {
      syslog ("keyboard: error:  Could not reserve controller port");
      exit ();
    }

    /* Reserve keyboard system resources. */
    if (subscribe_irq (KEYBOARD_IRQ, KEYBOARD_INTERRUPT_NO, 0) == -1) {
      syslog ("keyboard: error:  Could not subscribe to keyboard irq");
      exit ();
    }

    /* Create the keyboard output buffer. */
    keyboard_output_buffer_bd = buffer_create (0);
    if (keyboard_output_buffer_bd == -1) {
      syslog ("keyboard: error:  Could not create output buffer");
      exit ();
    }
    if (buffer_file_initw (&keyboard_output_buffer, keyboard_output_buffer_bd) == -1) {
      syslog ("keyboard: error:  Could not initialize output buffer");
      exit ();
    }

    /* Reserve mouse system resources. */
    if (subscribe_irq (MOUSE_IRQ, MOUSE_INTERRUPT_NO, 0) == -1) {
      syslog ("mouse: error:  Could not subscribe to mouse irq");
      exit ();
    }

    /* Create the mouse output buffer. */
    mouse_output_buffer_bd = buffer_create (0);
    if (mouse_output_buffer_bd == -1) {
      syslog ("mouse: error:  Could not create output buffer");
      exit ();
    }
    if (buffer_file_initw (&mouse_output_buffer, mouse_output_buffer_bd) == -1) {
      syslog ("mouse: error:  Could not initialize output buffer");
      exit ();
    }

    /* Handshakes with mouse hardware to initialize, done exactly once. */

    /* Enable aux port, have it generate mouse IRQ 12 */

    /* syslog("about to wait to send"); */
    mouse_wait_to_send();
    syslog("about to output ENABLE_AUX_DEVICE command");
    if (outb (CONTROLLER_PORT,ENABLE_AUX_DEVICE) == -1) {
      syslog ("mouse: error:  could not send enable aux device command to controller port");
      exit ();
    }

    /* syslog("about to wait to send"); */
    mouse_wait_to_send();
    /* syslog("about to send compaq status byte"); */
    if (outb (CONTROLLER_PORT,GET_COMPAQ_STATUS_BYTE ) == -1) {
      syslog ("mouse: error:  could not ask for status byte");
      exit ();
    }

    /* syslog("about to wait to read"); */
    mouse_wait_to_read();
    /* syslog("about to read from data port"); */
    unsigned char c = inb (DATA_PORT);
    if (automatonerrno != 0) {
      syslog ("mouse: error:  could not read compaq status byte");
      exit ();
    }
    c |= ENABLE_IRQ12_BIT;
    unsigned char delta = DISABLE_MOUSE_CLOCK_BIT;
    c &= (~delta);

    /* syslog("about to wait to send"); */
    mouse_wait_to_send();
    /* syslog("about to send updated status byte"); */
    if (outb (CONTROLLER_PORT,SET_COMPAQ_STATUS_BYTE ) == -1) {
      syslog ("mouse: error:  could not send status byte command to controller port");
      exit ();
    }

    /* syslog("about to wait to send"); */
    mouse_wait_to_send();
    /* syslog("about to send status byte"); */
    if (outb (DATA_PORT,c) == -1) {
      syslog ("mouse: error:  could not send updated status byte to data port");
      exit ();
    }

    /* Set mouse defaults (and disables packets)  */
    /* syslog("about to do data handshake"); */
    mouse_data_handshake();
    /* syslog("about to wait to send"); */
    mouse_wait_to_send();
    /* syslog("about to send command to enable mouse movement packets"); */
    if (outb (DATA_PORT,SET_DEFAULTS_AND_DISABLE_MOUSE) == -1) {
      syslog ("mouse: error:  could not set defaults command to controller");
      exit ();
    }
    syslog("about to wait for an ack");
    mouse_wait_for_ack();

    /* Enable transmission of packets  */
    /* syslog("about to do data handshake"); */
    mouse_data_handshake();
    /* syslog("about to wait to send"); */
    mouse_wait_to_send();
    /* syslog("about to send command to enable mouse movement packets"); */
    if (outb (DATA_PORT,ENABLE_MOUSE_MOVEMENT_PACKETS) == -1) {
      syslog ("mouse: error:  could not send enable packets command to controller");
      exit ();
    }
    syslog("about to wait for an ack");
    mouse_wait_for_ack();
    syslog("success!");

    /* TODO - is this a 3 byte mouse or a 4 byte mouse? 
       save state about that in a global variable, and adjust
       behavior accordingly (initially get 3 byte mouse to work) */

    /* TODO - get basic 3 byte mouse working with keyboard at same time */

    /* TODO - look through list of PS2 mouse commands and see what we would like to issue here or elsewhere */
  }
}

static void
schedule (void);

static void
end_input_action (bd_t bda,
		  bd_t bdb)
{
  if (bda != -1) {
    buffer_destroy (bda);
  }
  if (bdb != -1) {
    buffer_destroy (bdb);
  }
  schedule ();
  scheduler_finish (false, -1, -1);
}

static void
end_output_action (bool output_fired,
		   bd_t bda,
		   bd_t bdb)
{
  schedule ();
  scheduler_finish (output_fired, bda, bdb);
}

BEGIN_SYSTEM_INPUT (INIT, "", "", init, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  end_input_action (bda, bdb);
}

/* keyboard_interrupt
   ------------------
   Process a keyboard interrupt by reading the scancode.
   
   Post: keyboard_output_buffer_initialized == true && the output buffer is not empty
 */
BEGIN_SYSTEM_INPUT (KEYBOARD_INTERRUPT_NO, "", "", keyboard_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  if (buffer_file_put (&keyboard_output_buffer, inb (DATA_PORT)) == -1) {
    syslog ("keyboard: error:  Could not write to output buffer");
    exit ();
  }
  end_input_action (bda, bdb);
}

/* scan_code
   ---------
   Output the scancodes.
   
   Pre:  keyboard_output_buffer_initialized == true && the output buffer is not empty
   Post: keyboard_output_buffer_initialized == false
 */
static bool
scan_code_precondition (void)
{
  return buffer_file_size (&keyboard_output_buffer) != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, SCAN_CODE_NO, "scan_code", "buffer_file", scan_code, int param)
{
  initialize ();
  scheduler_remove (SCAN_CODE_NO, param);

  if (scan_code_precondition ()) {
    buffer_file_truncate (&keyboard_output_buffer);
    end_output_action (true, keyboard_output_buffer_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}


/*===*/

/* mouse_interrupt
   ------------------
   Process a mouse interrupt by reading the movement packet.
   
   Post: ???
 */
BEGIN_SYSTEM_INPUT (MOUSE_INTERRUPT_NO, "", "", mouse_interrupt, aid_t aid, bd_t bda, bd_t bdb)
{
  initialize ();
  syslog("got a mouse packet");
  end_input_action (bda, bdb);
}

/* Output the mouse packet
   ---------
   Output the mouse button and movement variables.
   
   Pre:  ???
   Post: ???
 */
static bool
mouse_packet_precondition (void)
{
  return buffer_file_size (&mouse_output_buffer) != 0;
}

BEGIN_OUTPUT (NO_PARAMETER, MOUSE_PACKET_NO, "mouse_packet", "buffer_file", mouse_packet, int param)
{
  initialize ();
  scheduler_remove (MOUSE_PACKET_NO, param);

  if (mouse_packet_precondition ()) {
    buffer_file_truncate (&mouse_output_buffer);
    end_output_action (true, mouse_output_buffer_bd, -1);
  }
  else {
    end_output_action (false, -1, -1);
  }
}

/*===*/

static void
schedule (void)
{
  if (scan_code_precondition ()) {
    scheduler_add (SCAN_CODE_NO, 0);
  }
  if (mouse_packet_precondition ()) {
    scheduler_add (MOUSE_PACKET_NO, 0);
  }
}
