2011-10-19

Started developing the kernel with the tutorial at http://wiki.osdev.org/Bare_bones
Decided to create ISO images for testing with Bochs.
The code for doing this can be found in the Makefile.
Developed two functions for printing strings and numbers in hex.
These functions were inspired by the tutorial at http://www.jamesmolloy.co.uk/tutorial_html/3.-The%20Screen.html

2011-10-20

Performed gymnastics trying to get GRUB2 to work.
I agree with http://wiki.osdev.org/GRUB_2 that GRUB2 changed their interface.
Added code to display a message and halt when there is multiboot error.
Added code to halt the processor at the end of the kernel.
Decided to use a higher-half kernel using the GDT trick described at http://wiki.osdev.org/Higher_Half_With_GDT
Switch to the NASM assembler because most of the examples I've found used NASM.
Most of the development time was spent looking up magic numbers.

2011-10-21

I'm currently using the Bochs simulator to test the kernel.
As I complete different pieces, I'll test using a physical machine to eliminate the difference between theory and practice.
Added an entry to /etc/grub.d/40_custom and copied the kernel to /boot.
Comment out the GRUB_HIDDEN_TIMEOUT variable in /etc/default/grub to make the boot menu appear.  (I'm using Ubuntu 10.04.)
The test using the physical machine was successful.
The following page describes x86 descriptor types: http://codewiki.wikispaces.com/x86+descriptor+types
First implementation of interrupts/traps.
Test on physical machine was successful.

2011-10-22

Added support for the programmable interrupt timer using code from http://www.jamesmolloy.co.uk/tutorial_html/5.-IRQs%20and%20the%20PIT.html and http://en.wikipedia.org/wiki/Intel_8253.
Test on physical machine was successful.

2011-10-23

Generalize interrupt handling.
Started parsing the multiboot header.
Wrote functions for extending the identity memory map.

2011-10-24

Wrote primitive page fault handler to debug extending the identity map.
Parsed the memory map provided by GRUB.
Test on physical machine was successful.

2011-10-25

Added a kassert macro to help debug and communicate assumptions.
Changed framebuffer to work before and after paging/GDT.
Added assertions related to identity mapping for memory management.
Test on physical machine was successful.
Setting an interrupt handler now changes the masks on the PICs.
Implemented a placement allocator.
Preliminary implemented of a manager for frames (physical pages).
Test on physical machine was successful.

2011-10-26

Fixed interrupt mask bug.
Refactored paging code.
Starting work on heap allocator.

2011-10-27

Finished heap allocator.
Test on a physical machine was successful.

2011-10-28

Implemented a basic hash map.
Kernel is mapped in all address spaces.

2011-10-29

Refactored descriptors.
I'm starting to think seriously about user-mode, automata, etc.
One observation is that the system needs a total of two stacks: one for the kernel to use for interrupts and one for user automata.
Since all context is stored in the state of the automaton, the same stack can be shared by all automata.

2011-10-30

An automaton resembles a libary.
The key question is how to dispatch into the automaton to execution actions.
One way is to dispatch directly, i.e., set the instruction pointer to the beginning of the code for an action.
The parameter associated with an action would be placed in registers.
To make composition safe, we would need a table of some kind that describes the valid entry points.
Another way is to dispatch indirectly by jumping to the same entry point but providing an action number in a register that the dispatching function could then translate into an appropriate offset.
Again, we would need a table describing the valid action numbers.
Direct dispatch is probably more efficient while indirect dispatch provides a level of indirection that makes composition easier.
Continuing this idea, suppose that every automaton provided the following tables:
1.  A table that translates from action number to entry point.
2.  A table that translates from action name to action number.
3.  A table that translates from action number to action name.
We could then do composition based on name which creates a number of possibilities like type checking a composition.
Based on this, I'm going to research if ELF symbol tables can support such features.

2011-10-31

Interrupts will only interact with the scheduler.
They will not be allowed to allocate memory.
Added a user stack to the kernel page directory.
After looking into ELF, I think I will write a post-processor to create the necessary tables in an object file that can be linked with the executable.
Implemented a simple automata set, FIFO scheduler, and system call interface.
Simulating an automaton that counts to 10 and stops was successful on a physical machine.
The next step will be to refactor the automaton to abstract the reusable parts.
My checkpoints going forward are:
1.  Refactor the count-to-ten automaton.
    Goal:  Polish syscall interface and start user-mode scheduler.
2.  Implement producer->consumer.
    The value will be transferred by register.
    Goal:  Composition.
3.  Implement producer->consumer->console.
    The value between consumer and console will be transferred by a buffer.
    Goal:  Implement buffers.

After this, the big goal is to implement the following composition:

+--------+
|  Init  |
+--------+
     ^
     |
     v
+--------+       +--------+
|   VFS  |<----->| System |
+--------+       +--------+
     ^
     |
     v
+--------+
| Initrd |
+--------+

The Init automaton will use the VFS and Initrd to load another another automaton (Init2?) that will bootstrap the rest of the system.
The Initrd can contain hardware drivers, system services, user apps. etc.
Later on, it will probably only contain the necessary drivers to read physical disks and file systems.

Also, I plan to implement 16 IRQ automata, each with a single output.
The associated interrupt just schedules the appropriate output.
